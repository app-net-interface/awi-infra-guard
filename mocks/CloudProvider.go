// Code generated by mockery v2.32.0. DO NOT EDIT.

package mocks

import (
	context "context"

	cluster "github.com/app-net-interface/kubernetes-discovery/cluster"

	infrapb "github.com/app-net-interface/awi-infra-guard/grpc/go/infrapb"

	mock "github.com/stretchr/testify/mock"

	types "github.com/app-net-interface/awi-infra-guard/types"
)

// CloudProvider is an autogenerated mock type for the CloudProvider type
type CloudProvider struct {
	mock.Mock
}

type CloudProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *CloudProvider) EXPECT() *CloudProvider_Expecter {
	return &CloudProvider_Expecter{mock: &_m.Mock}
}

// AddInboundAllowRuleByInstanceIPMatch provides a mock function with given fields: ctx, account, region, vpcID, ruleName, instancesIPs, cidrsToAllow, protocolsAndPorts
func (_m *CloudProvider) AddInboundAllowRuleByInstanceIPMatch(ctx context.Context, account string, region string, vpcID string, ruleName string, instancesIPs []string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts) (string, []types.Instance, error) {
	ret := _m.Called(ctx, account, region, vpcID, ruleName, instancesIPs, cidrsToAllow, protocolsAndPorts)

	var r0 string
	var r1 []types.Instance
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) (string, []types.Instance, error)); ok {
		return rf(ctx, account, region, vpcID, ruleName, instancesIPs, cidrsToAllow, protocolsAndPorts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) string); ok {
		r0 = rf(ctx, account, region, vpcID, ruleName, instancesIPs, cidrsToAllow, protocolsAndPorts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) []types.Instance); ok {
		r1 = rf(ctx, account, region, vpcID, ruleName, instancesIPs, cidrsToAllow, protocolsAndPorts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) error); ok {
		r2 = rf(ctx, account, region, vpcID, ruleName, instancesIPs, cidrsToAllow, protocolsAndPorts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleByInstanceIPMatch'
type CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call struct {
	*mock.Call
}

// AddInboundAllowRuleByInstanceIPMatch is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - vpcID string
//   - ruleName string
//   - instancesIPs []string
//   - cidrsToAllow []string
//   - protocolsAndPorts types.ProtocolsAndPorts
func (_e *CloudProvider_Expecter) AddInboundAllowRuleByInstanceIPMatch(ctx interface{}, account interface{}, region interface{}, vpcID interface{}, ruleName interface{}, instancesIPs interface{}, cidrsToAllow interface{}, protocolsAndPorts interface{}) *CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call {
	return &CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call{Call: _e.mock.On("AddInboundAllowRuleByInstanceIPMatch", ctx, account, region, vpcID, ruleName, instancesIPs, cidrsToAllow, protocolsAndPorts)}
}

func (_c *CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call) Run(run func(ctx context.Context, account string, region string, vpcID string, ruleName string, instancesIPs []string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts)) *CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].([]string), args[6].([]string), args[7].(types.ProtocolsAndPorts))
	})
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call) Return(ruleId string, instances []types.Instance, err error) *CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call {
	_c.Call.Return(ruleId, instances, err)
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call) RunAndReturn(run func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) (string, []types.Instance, error)) *CloudProvider_AddInboundAllowRuleByInstanceIPMatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleByLabelsMatch provides a mock function with given fields: ctx, account, region, vpcID, ruleName, labels, cidrsToAllow, protocolsAndPorts
func (_m *CloudProvider) AddInboundAllowRuleByLabelsMatch(ctx context.Context, account string, region string, vpcID string, ruleName string, labels map[string]string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts) (string, []types.Instance, error) {
	ret := _m.Called(ctx, account, region, vpcID, ruleName, labels, cidrsToAllow, protocolsAndPorts)

	var r0 string
	var r1 []types.Instance
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, map[string]string, []string, types.ProtocolsAndPorts) (string, []types.Instance, error)); ok {
		return rf(ctx, account, region, vpcID, ruleName, labels, cidrsToAllow, protocolsAndPorts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, map[string]string, []string, types.ProtocolsAndPorts) string); ok {
		r0 = rf(ctx, account, region, vpcID, ruleName, labels, cidrsToAllow, protocolsAndPorts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, map[string]string, []string, types.ProtocolsAndPorts) []types.Instance); ok {
		r1 = rf(ctx, account, region, vpcID, ruleName, labels, cidrsToAllow, protocolsAndPorts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, string, map[string]string, []string, types.ProtocolsAndPorts) error); ok {
		r2 = rf(ctx, account, region, vpcID, ruleName, labels, cidrsToAllow, protocolsAndPorts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CloudProvider_AddInboundAllowRuleByLabelsMatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleByLabelsMatch'
type CloudProvider_AddInboundAllowRuleByLabelsMatch_Call struct {
	*mock.Call
}

// AddInboundAllowRuleByLabelsMatch is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - vpcID string
//   - ruleName string
//   - labels map[string]string
//   - cidrsToAllow []string
//   - protocolsAndPorts types.ProtocolsAndPorts
func (_e *CloudProvider_Expecter) AddInboundAllowRuleByLabelsMatch(ctx interface{}, account interface{}, region interface{}, vpcID interface{}, ruleName interface{}, labels interface{}, cidrsToAllow interface{}, protocolsAndPorts interface{}) *CloudProvider_AddInboundAllowRuleByLabelsMatch_Call {
	return &CloudProvider_AddInboundAllowRuleByLabelsMatch_Call{Call: _e.mock.On("AddInboundAllowRuleByLabelsMatch", ctx, account, region, vpcID, ruleName, labels, cidrsToAllow, protocolsAndPorts)}
}

func (_c *CloudProvider_AddInboundAllowRuleByLabelsMatch_Call) Run(run func(ctx context.Context, account string, region string, vpcID string, ruleName string, labels map[string]string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts)) *CloudProvider_AddInboundAllowRuleByLabelsMatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(map[string]string), args[6].([]string), args[7].(types.ProtocolsAndPorts))
	})
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleByLabelsMatch_Call) Return(ruleId string, instances []types.Instance, err error) *CloudProvider_AddInboundAllowRuleByLabelsMatch_Call {
	_c.Call.Return(ruleId, instances, err)
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleByLabelsMatch_Call) RunAndReturn(run func(context.Context, string, string, string, string, map[string]string, []string, types.ProtocolsAndPorts) (string, []types.Instance, error)) *CloudProvider_AddInboundAllowRuleByLabelsMatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleBySubnetMatch provides a mock function with given fields: ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts
func (_m *CloudProvider) AddInboundAllowRuleBySubnetMatch(ctx context.Context, account string, region string, vpcID string, ruleName string, subnetCidrs []string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts) (string, []types.Instance, []types.Subnet, error) {
	ret := _m.Called(ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts)

	var r0 string
	var r1 []types.Instance
	var r2 []types.Subnet
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) (string, []types.Instance, []types.Subnet, error)); ok {
		return rf(ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) string); ok {
		r0 = rf(ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) []types.Instance); ok {
		r1 = rf(ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) []types.Subnet); ok {
		r2 = rf(ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]types.Subnet)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) error); ok {
		r3 = rf(ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// CloudProvider_AddInboundAllowRuleBySubnetMatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleBySubnetMatch'
type CloudProvider_AddInboundAllowRuleBySubnetMatch_Call struct {
	*mock.Call
}

// AddInboundAllowRuleBySubnetMatch is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - vpcID string
//   - ruleName string
//   - subnetCidrs []string
//   - cidrsToAllow []string
//   - protocolsAndPorts types.ProtocolsAndPorts
func (_e *CloudProvider_Expecter) AddInboundAllowRuleBySubnetMatch(ctx interface{}, account interface{}, region interface{}, vpcID interface{}, ruleName interface{}, subnetCidrs interface{}, cidrsToAllow interface{}, protocolsAndPorts interface{}) *CloudProvider_AddInboundAllowRuleBySubnetMatch_Call {
	return &CloudProvider_AddInboundAllowRuleBySubnetMatch_Call{Call: _e.mock.On("AddInboundAllowRuleBySubnetMatch", ctx, account, region, vpcID, ruleName, subnetCidrs, cidrsToAllow, protocolsAndPorts)}
}

func (_c *CloudProvider_AddInboundAllowRuleBySubnetMatch_Call) Run(run func(ctx context.Context, account string, region string, vpcID string, ruleName string, subnetCidrs []string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts)) *CloudProvider_AddInboundAllowRuleBySubnetMatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].([]string), args[6].([]string), args[7].(types.ProtocolsAndPorts))
	})
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleBySubnetMatch_Call) Return(ruleId string, instances []types.Instance, subnets []types.Subnet, err error) *CloudProvider_AddInboundAllowRuleBySubnetMatch_Call {
	_c.Call.Return(ruleId, instances, subnets, err)
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleBySubnetMatch_Call) RunAndReturn(run func(context.Context, string, string, string, string, []string, []string, types.ProtocolsAndPorts) (string, []types.Instance, []types.Subnet, error)) *CloudProvider_AddInboundAllowRuleBySubnetMatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleForLoadBalancerByDNS provides a mock function with given fields: ctx, account, region, loadBalancerDNS, vpcID, ruleName, cidrsToAllow, protocolsAndPorts
func (_m *CloudProvider) AddInboundAllowRuleForLoadBalancerByDNS(ctx context.Context, account string, region string, loadBalancerDNS string, vpcID string, ruleName string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts) (string, string, error) {
	ret := _m.Called(ctx, account, region, loadBalancerDNS, vpcID, ruleName, cidrsToAllow, protocolsAndPorts)

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, []string, types.ProtocolsAndPorts) (string, string, error)); ok {
		return rf(ctx, account, region, loadBalancerDNS, vpcID, ruleName, cidrsToAllow, protocolsAndPorts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, []string, types.ProtocolsAndPorts) string); ok {
		r0 = rf(ctx, account, region, loadBalancerDNS, vpcID, ruleName, cidrsToAllow, protocolsAndPorts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, []string, types.ProtocolsAndPorts) string); ok {
		r1 = rf(ctx, account, region, loadBalancerDNS, vpcID, ruleName, cidrsToAllow, protocolsAndPorts)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, string, string, []string, types.ProtocolsAndPorts) error); ok {
		r2 = rf(ctx, account, region, loadBalancerDNS, vpcID, ruleName, cidrsToAllow, protocolsAndPorts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleForLoadBalancerByDNS'
type CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call struct {
	*mock.Call
}

// AddInboundAllowRuleForLoadBalancerByDNS is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - loadBalancerDNS string
//   - vpcID string
//   - ruleName string
//   - cidrsToAllow []string
//   - protocolsAndPorts types.ProtocolsAndPorts
func (_e *CloudProvider_Expecter) AddInboundAllowRuleForLoadBalancerByDNS(ctx interface{}, account interface{}, region interface{}, loadBalancerDNS interface{}, vpcID interface{}, ruleName interface{}, cidrsToAllow interface{}, protocolsAndPorts interface{}) *CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	return &CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call{Call: _e.mock.On("AddInboundAllowRuleForLoadBalancerByDNS", ctx, account, region, loadBalancerDNS, vpcID, ruleName, cidrsToAllow, protocolsAndPorts)}
}

func (_c *CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call) Run(run func(ctx context.Context, account string, region string, loadBalancerDNS string, vpcID string, ruleName string, cidrsToAllow []string, protocolsAndPorts types.ProtocolsAndPorts)) *CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].([]string), args[7].(types.ProtocolsAndPorts))
	})
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call) Return(loadBalancerId string, ruleId string, err error) *CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	_c.Call.Return(loadBalancerId, ruleId, err)
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call) RunAndReturn(run func(context.Context, string, string, string, string, string, []string, types.ProtocolsAndPorts) (string, string, error)) *CloudProvider_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleInVPC provides a mock function with given fields: ctx, account, region, destinationVpcID, cidrsToAllow, ruleName, tags
func (_m *CloudProvider) AddInboundAllowRuleInVPC(ctx context.Context, account string, region string, destinationVpcID string, cidrsToAllow []string, ruleName string, tags map[string]string) error {
	ret := _m.Called(ctx, account, region, destinationVpcID, cidrsToAllow, ruleName, tags)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []string, string, map[string]string) error); ok {
		r0 = rf(ctx, account, region, destinationVpcID, cidrsToAllow, ruleName, tags)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloudProvider_AddInboundAllowRuleInVPC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleInVPC'
type CloudProvider_AddInboundAllowRuleInVPC_Call struct {
	*mock.Call
}

// AddInboundAllowRuleInVPC is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - destinationVpcID string
//   - cidrsToAllow []string
//   - ruleName string
//   - tags map[string]string
func (_e *CloudProvider_Expecter) AddInboundAllowRuleInVPC(ctx interface{}, account interface{}, region interface{}, destinationVpcID interface{}, cidrsToAllow interface{}, ruleName interface{}, tags interface{}) *CloudProvider_AddInboundAllowRuleInVPC_Call {
	return &CloudProvider_AddInboundAllowRuleInVPC_Call{Call: _e.mock.On("AddInboundAllowRuleInVPC", ctx, account, region, destinationVpcID, cidrsToAllow, ruleName, tags)}
}

func (_c *CloudProvider_AddInboundAllowRuleInVPC_Call) Run(run func(ctx context.Context, account string, region string, destinationVpcID string, cidrsToAllow []string, ruleName string, tags map[string]string)) *CloudProvider_AddInboundAllowRuleInVPC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].([]string), args[5].(string), args[6].(map[string]string))
	})
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleInVPC_Call) Return(_a0 error) *CloudProvider_AddInboundAllowRuleInVPC_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CloudProvider_AddInboundAllowRuleInVPC_Call) RunAndReturn(run func(context.Context, string, string, string, []string, string, map[string]string) error) *CloudProvider_AddInboundAllowRuleInVPC_Call {
	_c.Call.Return(run)
	return _c
}

// ConnectVPCs provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ConnectVPCs(ctx context.Context, input types.VPCConnectionParams) (types.VPCConnectionOutput, error) {
	ret := _m.Called(ctx, input)

	var r0 types.VPCConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.VPCConnectionParams) (types.VPCConnectionOutput, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.VPCConnectionParams) types.VPCConnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Get(0).(types.VPCConnectionOutput)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.VPCConnectionParams) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ConnectVPCs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectVPCs'
type CloudProvider_ConnectVPCs_Call struct {
	*mock.Call
}

// ConnectVPCs is a helper method to define mock.On call
//   - ctx context.Context
//   - input types.VPCConnectionParams
func (_e *CloudProvider_Expecter) ConnectVPCs(ctx interface{}, input interface{}) *CloudProvider_ConnectVPCs_Call {
	return &CloudProvider_ConnectVPCs_Call{Call: _e.mock.On("ConnectVPCs", ctx, input)}
}

func (_c *CloudProvider_ConnectVPCs_Call) Run(run func(ctx context.Context, input types.VPCConnectionParams)) *CloudProvider_ConnectVPCs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.VPCConnectionParams))
	})
	return _c
}

func (_c *CloudProvider_ConnectVPCs_Call) Return(_a0 types.VPCConnectionOutput, _a1 error) *CloudProvider_ConnectVPCs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ConnectVPCs_Call) RunAndReturn(run func(context.Context, types.VPCConnectionParams) (types.VPCConnectionOutput, error)) *CloudProvider_ConnectVPCs_Call {
	_c.Call.Return(run)
	return _c
}

// DisconnectVPCs provides a mock function with given fields: ctx, input
func (_m *CloudProvider) DisconnectVPCs(ctx context.Context, input types.VPCDisconnectionParams) (types.VPCDisconnectionOutput, error) {
	ret := _m.Called(ctx, input)

	var r0 types.VPCDisconnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.VPCDisconnectionParams) (types.VPCDisconnectionOutput, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.VPCDisconnectionParams) types.VPCDisconnectionOutput); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Get(0).(types.VPCDisconnectionOutput)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.VPCDisconnectionParams) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_DisconnectVPCs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisconnectVPCs'
type CloudProvider_DisconnectVPCs_Call struct {
	*mock.Call
}

// DisconnectVPCs is a helper method to define mock.On call
//   - ctx context.Context
//   - input types.VPCDisconnectionParams
func (_e *CloudProvider_Expecter) DisconnectVPCs(ctx interface{}, input interface{}) *CloudProvider_DisconnectVPCs_Call {
	return &CloudProvider_DisconnectVPCs_Call{Call: _e.mock.On("DisconnectVPCs", ctx, input)}
}

func (_c *CloudProvider_DisconnectVPCs_Call) Run(run func(ctx context.Context, input types.VPCDisconnectionParams)) *CloudProvider_DisconnectVPCs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.VPCDisconnectionParams))
	})
	return _c
}

func (_c *CloudProvider_DisconnectVPCs_Call) Return(_a0 types.VPCDisconnectionOutput, _a1 error) *CloudProvider_DisconnectVPCs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_DisconnectVPCs_Call) RunAndReturn(run func(context.Context, types.VPCDisconnectionParams) (types.VPCDisconnectionOutput, error)) *CloudProvider_DisconnectVPCs_Call {
	_c.Call.Return(run)
	return _c
}

// GetCIDRsForLabels provides a mock function with given fields: ctx, input
func (_m *CloudProvider) GetCIDRsForLabels(ctx context.Context, input *infrapb.GetCIDRsForLabelsRequest) ([]string, error) {
	ret := _m.Called(ctx, input)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetCIDRsForLabelsRequest) ([]string, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetCIDRsForLabelsRequest) []string); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.GetCIDRsForLabelsRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_GetCIDRsForLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCIDRsForLabels'
type CloudProvider_GetCIDRsForLabels_Call struct {
	*mock.Call
}

// GetCIDRsForLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.GetCIDRsForLabelsRequest
func (_e *CloudProvider_Expecter) GetCIDRsForLabels(ctx interface{}, input interface{}) *CloudProvider_GetCIDRsForLabels_Call {
	return &CloudProvider_GetCIDRsForLabels_Call{Call: _e.mock.On("GetCIDRsForLabels", ctx, input)}
}

func (_c *CloudProvider_GetCIDRsForLabels_Call) Run(run func(ctx context.Context, input *infrapb.GetCIDRsForLabelsRequest)) *CloudProvider_GetCIDRsForLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.GetCIDRsForLabelsRequest))
	})
	return _c
}

func (_c *CloudProvider_GetCIDRsForLabels_Call) Return(_a0 []string, _a1 error) *CloudProvider_GetCIDRsForLabels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_GetCIDRsForLabels_Call) RunAndReturn(run func(context.Context, *infrapb.GetCIDRsForLabelsRequest) ([]string, error)) *CloudProvider_GetCIDRsForLabels_Call {
	_c.Call.Return(run)
	return _c
}

// GetIPsForLabels provides a mock function with given fields: ctx, input
func (_m *CloudProvider) GetIPsForLabels(ctx context.Context, input *infrapb.GetIPsForLabelsRequest) ([]string, error) {
	ret := _m.Called(ctx, input)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetIPsForLabelsRequest) ([]string, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetIPsForLabelsRequest) []string); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.GetIPsForLabelsRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_GetIPsForLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIPsForLabels'
type CloudProvider_GetIPsForLabels_Call struct {
	*mock.Call
}

// GetIPsForLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.GetIPsForLabelsRequest
func (_e *CloudProvider_Expecter) GetIPsForLabels(ctx interface{}, input interface{}) *CloudProvider_GetIPsForLabels_Call {
	return &CloudProvider_GetIPsForLabels_Call{Call: _e.mock.On("GetIPsForLabels", ctx, input)}
}

func (_c *CloudProvider_GetIPsForLabels_Call) Run(run func(ctx context.Context, input *infrapb.GetIPsForLabelsRequest)) *CloudProvider_GetIPsForLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.GetIPsForLabelsRequest))
	})
	return _c
}

func (_c *CloudProvider_GetIPsForLabels_Call) Return(_a0 []string, _a1 error) *CloudProvider_GetIPsForLabels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_GetIPsForLabels_Call) RunAndReturn(run func(context.Context, *infrapb.GetIPsForLabelsRequest) ([]string, error)) *CloudProvider_GetIPsForLabels_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstancesForLabels provides a mock function with given fields: ctx, input
func (_m *CloudProvider) GetInstancesForLabels(ctx context.Context, input *infrapb.GetInstancesForLabelsRequest) ([]types.Instance, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetInstancesForLabelsRequest) ([]types.Instance, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetInstancesForLabelsRequest) []types.Instance); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.GetInstancesForLabelsRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_GetInstancesForLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstancesForLabels'
type CloudProvider_GetInstancesForLabels_Call struct {
	*mock.Call
}

// GetInstancesForLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.GetInstancesForLabelsRequest
func (_e *CloudProvider_Expecter) GetInstancesForLabels(ctx interface{}, input interface{}) *CloudProvider_GetInstancesForLabels_Call {
	return &CloudProvider_GetInstancesForLabels_Call{Call: _e.mock.On("GetInstancesForLabels", ctx, input)}
}

func (_c *CloudProvider_GetInstancesForLabels_Call) Run(run func(ctx context.Context, input *infrapb.GetInstancesForLabelsRequest)) *CloudProvider_GetInstancesForLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.GetInstancesForLabelsRequest))
	})
	return _c
}

func (_c *CloudProvider_GetInstancesForLabels_Call) Return(_a0 []types.Instance, _a1 error) *CloudProvider_GetInstancesForLabels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_GetInstancesForLabels_Call) RunAndReturn(run func(context.Context, *infrapb.GetInstancesForLabelsRequest) ([]types.Instance, error)) *CloudProvider_GetInstancesForLabels_Call {
	_c.Call.Return(run)
	return _c
}

// GetName provides a mock function with given fields:
func (_m *CloudProvider) GetName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// CloudProvider_GetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetName'
type CloudProvider_GetName_Call struct {
	*mock.Call
}

// GetName is a helper method to define mock.On call
func (_e *CloudProvider_Expecter) GetName() *CloudProvider_GetName_Call {
	return &CloudProvider_GetName_Call{Call: _e.mock.On("GetName")}
}

func (_c *CloudProvider_GetName_Call) Run(run func()) *CloudProvider_GetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CloudProvider_GetName_Call) Return(_a0 string) *CloudProvider_GetName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CloudProvider_GetName_Call) RunAndReturn(run func() string) *CloudProvider_GetName_Call {
	_c.Call.Return(run)
	return _c
}

// GetSubnet provides a mock function with given fields: ctx, input
func (_m *CloudProvider) GetSubnet(ctx context.Context, input *infrapb.GetSubnetRequest) (types.Subnet, error) {
	ret := _m.Called(ctx, input)

	var r0 types.Subnet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetSubnetRequest) (types.Subnet, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetSubnetRequest) types.Subnet); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Get(0).(types.Subnet)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.GetSubnetRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_GetSubnet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSubnet'
type CloudProvider_GetSubnet_Call struct {
	*mock.Call
}

// GetSubnet is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.GetSubnetRequest
func (_e *CloudProvider_Expecter) GetSubnet(ctx interface{}, input interface{}) *CloudProvider_GetSubnet_Call {
	return &CloudProvider_GetSubnet_Call{Call: _e.mock.On("GetSubnet", ctx, input)}
}

func (_c *CloudProvider_GetSubnet_Call) Run(run func(ctx context.Context, input *infrapb.GetSubnetRequest)) *CloudProvider_GetSubnet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.GetSubnetRequest))
	})
	return _c
}

func (_c *CloudProvider_GetSubnet_Call) Return(_a0 types.Subnet, _a1 error) *CloudProvider_GetSubnet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_GetSubnet_Call) RunAndReturn(run func(context.Context, *infrapb.GetSubnetRequest) (types.Subnet, error)) *CloudProvider_GetSubnet_Call {
	_c.Call.Return(run)
	return _c
}

// GetSyncTime provides a mock function with given fields: id
func (_m *CloudProvider) GetSyncTime(id string) (types.SyncTime, error) {
	ret := _m.Called(id)

	var r0 types.SyncTime
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (types.SyncTime, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(string) types.SyncTime); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(types.SyncTime)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_GetSyncTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSyncTime'
type CloudProvider_GetSyncTime_Call struct {
	*mock.Call
}

// GetSyncTime is a helper method to define mock.On call
//   - id string
func (_e *CloudProvider_Expecter) GetSyncTime(id interface{}) *CloudProvider_GetSyncTime_Call {
	return &CloudProvider_GetSyncTime_Call{Call: _e.mock.On("GetSyncTime", id)}
}

func (_c *CloudProvider_GetSyncTime_Call) Run(run func(id string)) *CloudProvider_GetSyncTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *CloudProvider_GetSyncTime_Call) Return(_a0 types.SyncTime, _a1 error) *CloudProvider_GetSyncTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_GetSyncTime_Call) RunAndReturn(run func(string) (types.SyncTime, error)) *CloudProvider_GetSyncTime_Call {
	_c.Call.Return(run)
	return _c
}

// GetVPCIDForCIDR provides a mock function with given fields: ctx, input
func (_m *CloudProvider) GetVPCIDForCIDR(ctx context.Context, input *infrapb.GetVPCIDForCIDRRequest) (string, error) {
	ret := _m.Called(ctx, input)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetVPCIDForCIDRRequest) (string, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetVPCIDForCIDRRequest) string); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.GetVPCIDForCIDRRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_GetVPCIDForCIDR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVPCIDForCIDR'
type CloudProvider_GetVPCIDForCIDR_Call struct {
	*mock.Call
}

// GetVPCIDForCIDR is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.GetVPCIDForCIDRRequest
func (_e *CloudProvider_Expecter) GetVPCIDForCIDR(ctx interface{}, input interface{}) *CloudProvider_GetVPCIDForCIDR_Call {
	return &CloudProvider_GetVPCIDForCIDR_Call{Call: _e.mock.On("GetVPCIDForCIDR", ctx, input)}
}

func (_c *CloudProvider_GetVPCIDForCIDR_Call) Run(run func(ctx context.Context, input *infrapb.GetVPCIDForCIDRRequest)) *CloudProvider_GetVPCIDForCIDR_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.GetVPCIDForCIDRRequest))
	})
	return _c
}

func (_c *CloudProvider_GetVPCIDForCIDR_Call) Return(_a0 string, _a1 error) *CloudProvider_GetVPCIDForCIDR_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_GetVPCIDForCIDR_Call) RunAndReturn(run func(context.Context, *infrapb.GetVPCIDForCIDRRequest) (string, error)) *CloudProvider_GetVPCIDForCIDR_Call {
	_c.Call.Return(run)
	return _c
}

// GetVPCIDWithTag provides a mock function with given fields: ctx, input
func (_m *CloudProvider) GetVPCIDWithTag(ctx context.Context, input *infrapb.GetVPCIDWithTagRequest) (string, error) {
	ret := _m.Called(ctx, input)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetVPCIDWithTagRequest) (string, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.GetVPCIDWithTagRequest) string); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.GetVPCIDWithTagRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_GetVPCIDWithTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVPCIDWithTag'
type CloudProvider_GetVPCIDWithTag_Call struct {
	*mock.Call
}

// GetVPCIDWithTag is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.GetVPCIDWithTagRequest
func (_e *CloudProvider_Expecter) GetVPCIDWithTag(ctx interface{}, input interface{}) *CloudProvider_GetVPCIDWithTag_Call {
	return &CloudProvider_GetVPCIDWithTag_Call{Call: _e.mock.On("GetVPCIDWithTag", ctx, input)}
}

func (_c *CloudProvider_GetVPCIDWithTag_Call) Run(run func(ctx context.Context, input *infrapb.GetVPCIDWithTagRequest)) *CloudProvider_GetVPCIDWithTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.GetVPCIDWithTagRequest))
	})
	return _c
}

func (_c *CloudProvider_GetVPCIDWithTag_Call) Return(_a0 string, _a1 error) *CloudProvider_GetVPCIDWithTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_GetVPCIDWithTag_Call) RunAndReturn(run func(context.Context, *infrapb.GetVPCIDWithTagRequest) (string, error)) *CloudProvider_GetVPCIDWithTag_Call {
	_c.Call.Return(run)
	return _c
}

// ListACLs provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ListACLs(ctx context.Context, input *infrapb.ListACLsRequest) ([]types.ACL, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.ACL
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListACLsRequest) ([]types.ACL, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListACLsRequest) []types.ACL); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ACL)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.ListACLsRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ListACLs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListACLs'
type CloudProvider_ListACLs_Call struct {
	*mock.Call
}

// ListACLs is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.ListACLsRequest
func (_e *CloudProvider_Expecter) ListACLs(ctx interface{}, input interface{}) *CloudProvider_ListACLs_Call {
	return &CloudProvider_ListACLs_Call{Call: _e.mock.On("ListACLs", ctx, input)}
}

func (_c *CloudProvider_ListACLs_Call) Run(run func(ctx context.Context, input *infrapb.ListACLsRequest)) *CloudProvider_ListACLs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.ListACLsRequest))
	})
	return _c
}

func (_c *CloudProvider_ListACLs_Call) Return(_a0 []types.ACL, _a1 error) *CloudProvider_ListACLs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ListACLs_Call) RunAndReturn(run func(context.Context, *infrapb.ListACLsRequest) ([]types.ACL, error)) *CloudProvider_ListACLs_Call {
	_c.Call.Return(run)
	return _c
}

// ListAccounts provides a mock function with given fields:
func (_m *CloudProvider) ListAccounts() []types.Account {
	ret := _m.Called()

	var r0 []types.Account
	if rf, ok := ret.Get(0).(func() []types.Account); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Account)
		}
	}

	return r0
}

// CloudProvider_ListAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAccounts'
type CloudProvider_ListAccounts_Call struct {
	*mock.Call
}

// ListAccounts is a helper method to define mock.On call
func (_e *CloudProvider_Expecter) ListAccounts() *CloudProvider_ListAccounts_Call {
	return &CloudProvider_ListAccounts_Call{Call: _e.mock.On("ListAccounts")}
}

func (_c *CloudProvider_ListAccounts_Call) Run(run func()) *CloudProvider_ListAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CloudProvider_ListAccounts_Call) Return(_a0 []types.Account) *CloudProvider_ListAccounts_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CloudProvider_ListAccounts_Call) RunAndReturn(run func() []types.Account) *CloudProvider_ListAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListClusters provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ListClusters(ctx context.Context, input *infrapb.ListCloudClustersRequest) ([]types.Cluster, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.Cluster
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListCloudClustersRequest) ([]types.Cluster, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListCloudClustersRequest) []types.Cluster); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Cluster)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.ListCloudClustersRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ListClusters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListClusters'
type CloudProvider_ListClusters_Call struct {
	*mock.Call
}

// ListClusters is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.ListCloudClustersRequest
func (_e *CloudProvider_Expecter) ListClusters(ctx interface{}, input interface{}) *CloudProvider_ListClusters_Call {
	return &CloudProvider_ListClusters_Call{Call: _e.mock.On("ListClusters", ctx, input)}
}

func (_c *CloudProvider_ListClusters_Call) Run(run func(ctx context.Context, input *infrapb.ListCloudClustersRequest)) *CloudProvider_ListClusters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.ListCloudClustersRequest))
	})
	return _c
}

func (_c *CloudProvider_ListClusters_Call) Return(_a0 []types.Cluster, _a1 error) *CloudProvider_ListClusters_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ListClusters_Call) RunAndReturn(run func(context.Context, *infrapb.ListCloudClustersRequest) ([]types.Cluster, error)) *CloudProvider_ListClusters_Call {
	_c.Call.Return(run)
	return _c
}

// ListInstances provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ListInstances(ctx context.Context, input *infrapb.ListInstancesRequest) ([]types.Instance, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListInstancesRequest) ([]types.Instance, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListInstancesRequest) []types.Instance); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.ListInstancesRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ListInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInstances'
type CloudProvider_ListInstances_Call struct {
	*mock.Call
}

// ListInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.ListInstancesRequest
func (_e *CloudProvider_Expecter) ListInstances(ctx interface{}, input interface{}) *CloudProvider_ListInstances_Call {
	return &CloudProvider_ListInstances_Call{Call: _e.mock.On("ListInstances", ctx, input)}
}

func (_c *CloudProvider_ListInstances_Call) Run(run func(ctx context.Context, input *infrapb.ListInstancesRequest)) *CloudProvider_ListInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.ListInstancesRequest))
	})
	return _c
}

func (_c *CloudProvider_ListInstances_Call) Return(_a0 []types.Instance, _a1 error) *CloudProvider_ListInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ListInstances_Call) RunAndReturn(run func(context.Context, *infrapb.ListInstancesRequest) ([]types.Instance, error)) *CloudProvider_ListInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ListRouteTables provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ListRouteTables(ctx context.Context, input *infrapb.ListRouteTablesRequest) ([]types.RouteTable, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.RouteTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListRouteTablesRequest) ([]types.RouteTable, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListRouteTablesRequest) []types.RouteTable); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.RouteTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.ListRouteTablesRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ListRouteTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRouteTables'
type CloudProvider_ListRouteTables_Call struct {
	*mock.Call
}

// ListRouteTables is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.ListRouteTablesRequest
func (_e *CloudProvider_Expecter) ListRouteTables(ctx interface{}, input interface{}) *CloudProvider_ListRouteTables_Call {
	return &CloudProvider_ListRouteTables_Call{Call: _e.mock.On("ListRouteTables", ctx, input)}
}

func (_c *CloudProvider_ListRouteTables_Call) Run(run func(ctx context.Context, input *infrapb.ListRouteTablesRequest)) *CloudProvider_ListRouteTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.ListRouteTablesRequest))
	})
	return _c
}

func (_c *CloudProvider_ListRouteTables_Call) Return(_a0 []types.RouteTable, _a1 error) *CloudProvider_ListRouteTables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ListRouteTables_Call) RunAndReturn(run func(context.Context, *infrapb.ListRouteTablesRequest) ([]types.RouteTable, error)) *CloudProvider_ListRouteTables_Call {
	_c.Call.Return(run)
	return _c
}

// ListSecurityGroups provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ListSecurityGroups(ctx context.Context, input *infrapb.ListSecurityGroupsRequest) ([]types.SecurityGroup, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.SecurityGroup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListSecurityGroupsRequest) ([]types.SecurityGroup, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListSecurityGroupsRequest) []types.SecurityGroup); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.SecurityGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.ListSecurityGroupsRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ListSecurityGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSecurityGroups'
type CloudProvider_ListSecurityGroups_Call struct {
	*mock.Call
}

// ListSecurityGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.ListSecurityGroupsRequest
func (_e *CloudProvider_Expecter) ListSecurityGroups(ctx interface{}, input interface{}) *CloudProvider_ListSecurityGroups_Call {
	return &CloudProvider_ListSecurityGroups_Call{Call: _e.mock.On("ListSecurityGroups", ctx, input)}
}

func (_c *CloudProvider_ListSecurityGroups_Call) Run(run func(ctx context.Context, input *infrapb.ListSecurityGroupsRequest)) *CloudProvider_ListSecurityGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.ListSecurityGroupsRequest))
	})
	return _c
}

func (_c *CloudProvider_ListSecurityGroups_Call) Return(_a0 []types.SecurityGroup, _a1 error) *CloudProvider_ListSecurityGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ListSecurityGroups_Call) RunAndReturn(run func(context.Context, *infrapb.ListSecurityGroupsRequest) ([]types.SecurityGroup, error)) *CloudProvider_ListSecurityGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListSubnets provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ListSubnets(ctx context.Context, input *infrapb.ListSubnetsRequest) ([]types.Subnet, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.Subnet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListSubnetsRequest) ([]types.Subnet, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListSubnetsRequest) []types.Subnet); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Subnet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.ListSubnetsRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ListSubnets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSubnets'
type CloudProvider_ListSubnets_Call struct {
	*mock.Call
}

// ListSubnets is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.ListSubnetsRequest
func (_e *CloudProvider_Expecter) ListSubnets(ctx interface{}, input interface{}) *CloudProvider_ListSubnets_Call {
	return &CloudProvider_ListSubnets_Call{Call: _e.mock.On("ListSubnets", ctx, input)}
}

func (_c *CloudProvider_ListSubnets_Call) Run(run func(ctx context.Context, input *infrapb.ListSubnetsRequest)) *CloudProvider_ListSubnets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.ListSubnetsRequest))
	})
	return _c
}

func (_c *CloudProvider_ListSubnets_Call) Return(_a0 []types.Subnet, _a1 error) *CloudProvider_ListSubnets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ListSubnets_Call) RunAndReturn(run func(context.Context, *infrapb.ListSubnetsRequest) ([]types.Subnet, error)) *CloudProvider_ListSubnets_Call {
	_c.Call.Return(run)
	return _c
}

// ListVPC provides a mock function with given fields: ctx, input
func (_m *CloudProvider) ListVPC(ctx context.Context, input *infrapb.ListVPCRequest) ([]types.VPC, error) {
	ret := _m.Called(ctx, input)

	var r0 []types.VPC
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListVPCRequest) ([]types.VPC, error)); ok {
		return rf(ctx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.ListVPCRequest) []types.VPC); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.VPC)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.ListVPCRequest) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_ListVPC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListVPC'
type CloudProvider_ListVPC_Call struct {
	*mock.Call
}

// ListVPC is a helper method to define mock.On call
//   - ctx context.Context
//   - input *infrapb.ListVPCRequest
func (_e *CloudProvider_Expecter) ListVPC(ctx interface{}, input interface{}) *CloudProvider_ListVPC_Call {
	return &CloudProvider_ListVPC_Call{Call: _e.mock.On("ListVPC", ctx, input)}
}

func (_c *CloudProvider_ListVPC_Call) Run(run func(ctx context.Context, input *infrapb.ListVPCRequest)) *CloudProvider_ListVPC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*infrapb.ListVPCRequest))
	})
	return _c
}

func (_c *CloudProvider_ListVPC_Call) Return(_a0 []types.VPC, _a1 error) *CloudProvider_ListVPC_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_ListVPC_Call) RunAndReturn(run func(context.Context, *infrapb.ListVPCRequest) ([]types.VPC, error)) *CloudProvider_ListVPC_Call {
	_c.Call.Return(run)
	return _c
}

// RefreshInboundAllowRule provides a mock function with given fields: ctx, account, region, ruleId, cidrsToAdd, cidrsToRemove, destinationLabels, destinationPrefixes, destinationVPCId, protocolsAndPorts
func (_m *CloudProvider) RefreshInboundAllowRule(ctx context.Context, account string, region string, ruleId string, cidrsToAdd []string, cidrsToRemove []string, destinationLabels map[string]string, destinationPrefixes []string, destinationVPCId string, protocolsAndPorts types.ProtocolsAndPorts) ([]types.Instance, []types.Subnet, error) {
	ret := _m.Called(ctx, account, region, ruleId, cidrsToAdd, cidrsToRemove, destinationLabels, destinationPrefixes, destinationVPCId, protocolsAndPorts)

	var r0 []types.Instance
	var r1 []types.Subnet
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []string, []string, map[string]string, []string, string, types.ProtocolsAndPorts) ([]types.Instance, []types.Subnet, error)); ok {
		return rf(ctx, account, region, ruleId, cidrsToAdd, cidrsToRemove, destinationLabels, destinationPrefixes, destinationVPCId, protocolsAndPorts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []string, []string, map[string]string, []string, string, types.ProtocolsAndPorts) []types.Instance); ok {
		r0 = rf(ctx, account, region, ruleId, cidrsToAdd, cidrsToRemove, destinationLabels, destinationPrefixes, destinationVPCId, protocolsAndPorts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, []string, []string, map[string]string, []string, string, types.ProtocolsAndPorts) []types.Subnet); ok {
		r1 = rf(ctx, account, region, ruleId, cidrsToAdd, cidrsToRemove, destinationLabels, destinationPrefixes, destinationVPCId, protocolsAndPorts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]types.Subnet)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, []string, []string, map[string]string, []string, string, types.ProtocolsAndPorts) error); ok {
		r2 = rf(ctx, account, region, ruleId, cidrsToAdd, cidrsToRemove, destinationLabels, destinationPrefixes, destinationVPCId, protocolsAndPorts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CloudProvider_RefreshInboundAllowRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefreshInboundAllowRule'
type CloudProvider_RefreshInboundAllowRule_Call struct {
	*mock.Call
}

// RefreshInboundAllowRule is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - ruleId string
//   - cidrsToAdd []string
//   - cidrsToRemove []string
//   - destinationLabels map[string]string
//   - destinationPrefixes []string
//   - destinationVPCId string
//   - protocolsAndPorts types.ProtocolsAndPorts
func (_e *CloudProvider_Expecter) RefreshInboundAllowRule(ctx interface{}, account interface{}, region interface{}, ruleId interface{}, cidrsToAdd interface{}, cidrsToRemove interface{}, destinationLabels interface{}, destinationPrefixes interface{}, destinationVPCId interface{}, protocolsAndPorts interface{}) *CloudProvider_RefreshInboundAllowRule_Call {
	return &CloudProvider_RefreshInboundAllowRule_Call{Call: _e.mock.On("RefreshInboundAllowRule", ctx, account, region, ruleId, cidrsToAdd, cidrsToRemove, destinationLabels, destinationPrefixes, destinationVPCId, protocolsAndPorts)}
}

func (_c *CloudProvider_RefreshInboundAllowRule_Call) Run(run func(ctx context.Context, account string, region string, ruleId string, cidrsToAdd []string, cidrsToRemove []string, destinationLabels map[string]string, destinationPrefixes []string, destinationVPCId string, protocolsAndPorts types.ProtocolsAndPorts)) *CloudProvider_RefreshInboundAllowRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].([]string), args[5].([]string), args[6].(map[string]string), args[7].([]string), args[8].(string), args[9].(types.ProtocolsAndPorts))
	})
	return _c
}

func (_c *CloudProvider_RefreshInboundAllowRule_Call) Return(instances []types.Instance, subnets []types.Subnet, err error) *CloudProvider_RefreshInboundAllowRule_Call {
	_c.Call.Return(instances, subnets, err)
	return _c
}

func (_c *CloudProvider_RefreshInboundAllowRule_Call) RunAndReturn(run func(context.Context, string, string, string, []string, []string, map[string]string, []string, string, types.ProtocolsAndPorts) ([]types.Instance, []types.Subnet, error)) *CloudProvider_RefreshInboundAllowRule_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveInboundAllowRuleFromVPCByName provides a mock function with given fields: ctx, account, region, vpcID, ruleName
func (_m *CloudProvider) RemoveInboundAllowRuleFromVPCByName(ctx context.Context, account string, region string, vpcID string, ruleName string) error {
	ret := _m.Called(ctx, account, region, vpcID, ruleName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) error); ok {
		r0 = rf(ctx, account, region, vpcID, ruleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveInboundAllowRuleFromVPCByName'
type CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call struct {
	*mock.Call
}

// RemoveInboundAllowRuleFromVPCByName is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - vpcID string
//   - ruleName string
func (_e *CloudProvider_Expecter) RemoveInboundAllowRuleFromVPCByName(ctx interface{}, account interface{}, region interface{}, vpcID interface{}, ruleName interface{}) *CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call {
	return &CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call{Call: _e.mock.On("RemoveInboundAllowRuleFromVPCByName", ctx, account, region, vpcID, ruleName)}
}

func (_c *CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call) Run(run func(ctx context.Context, account string, region string, vpcID string, ruleName string)) *CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call) Return(_a0 error) *CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call) RunAndReturn(run func(context.Context, string, string, string, string) error) *CloudProvider_RemoveInboundAllowRuleFromVPCByName_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveInboundAllowRuleRulesByTags provides a mock function with given fields: ctx, account, region, vpcID, ruleName, tags
func (_m *CloudProvider) RemoveInboundAllowRuleRulesByTags(ctx context.Context, account string, region string, vpcID string, ruleName string, tags map[string]string) error {
	ret := _m.Called(ctx, account, region, vpcID, ruleName, tags)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, map[string]string) error); ok {
		r0 = rf(ctx, account, region, vpcID, ruleName, tags)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloudProvider_RemoveInboundAllowRuleRulesByTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveInboundAllowRuleRulesByTags'
type CloudProvider_RemoveInboundAllowRuleRulesByTags_Call struct {
	*mock.Call
}

// RemoveInboundAllowRuleRulesByTags is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - vpcID string
//   - ruleName string
//   - tags map[string]string
func (_e *CloudProvider_Expecter) RemoveInboundAllowRuleRulesByTags(ctx interface{}, account interface{}, region interface{}, vpcID interface{}, ruleName interface{}, tags interface{}) *CloudProvider_RemoveInboundAllowRuleRulesByTags_Call {
	return &CloudProvider_RemoveInboundAllowRuleRulesByTags_Call{Call: _e.mock.On("RemoveInboundAllowRuleRulesByTags", ctx, account, region, vpcID, ruleName, tags)}
}

func (_c *CloudProvider_RemoveInboundAllowRuleRulesByTags_Call) Run(run func(ctx context.Context, account string, region string, vpcID string, ruleName string, tags map[string]string)) *CloudProvider_RemoveInboundAllowRuleRulesByTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(map[string]string))
	})
	return _c
}

func (_c *CloudProvider_RemoveInboundAllowRuleRulesByTags_Call) Return(_a0 error) *CloudProvider_RemoveInboundAllowRuleRulesByTags_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CloudProvider_RemoveInboundAllowRuleRulesByTags_Call) RunAndReturn(run func(context.Context, string, string, string, string, map[string]string) error) *CloudProvider_RemoveInboundAllowRuleRulesByTags_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveInboundAllowRulesFromVPCById provides a mock function with given fields: ctx, account, region, vpcID, instanceIDs, loadBalancersIDs, ruleId
func (_m *CloudProvider) RemoveInboundAllowRulesFromVPCById(ctx context.Context, account string, region string, vpcID string, instanceIDs []string, loadBalancersIDs []string, ruleId string) error {
	ret := _m.Called(ctx, account, region, vpcID, instanceIDs, loadBalancersIDs, ruleId)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []string, []string, string) error); ok {
		r0 = rf(ctx, account, region, vpcID, instanceIDs, loadBalancersIDs, ruleId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloudProvider_RemoveInboundAllowRulesFromVPCById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveInboundAllowRulesFromVPCById'
type CloudProvider_RemoveInboundAllowRulesFromVPCById_Call struct {
	*mock.Call
}

// RemoveInboundAllowRulesFromVPCById is a helper method to define mock.On call
//   - ctx context.Context
//   - account string
//   - region string
//   - vpcID string
//   - instanceIDs []string
//   - loadBalancersIDs []string
//   - ruleId string
func (_e *CloudProvider_Expecter) RemoveInboundAllowRulesFromVPCById(ctx interface{}, account interface{}, region interface{}, vpcID interface{}, instanceIDs interface{}, loadBalancersIDs interface{}, ruleId interface{}) *CloudProvider_RemoveInboundAllowRulesFromVPCById_Call {
	return &CloudProvider_RemoveInboundAllowRulesFromVPCById_Call{Call: _e.mock.On("RemoveInboundAllowRulesFromVPCById", ctx, account, region, vpcID, instanceIDs, loadBalancersIDs, ruleId)}
}

func (_c *CloudProvider_RemoveInboundAllowRulesFromVPCById_Call) Run(run func(ctx context.Context, account string, region string, vpcID string, instanceIDs []string, loadBalancersIDs []string, ruleId string)) *CloudProvider_RemoveInboundAllowRulesFromVPCById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].([]string), args[5].([]string), args[6].(string))
	})
	return _c
}

func (_c *CloudProvider_RemoveInboundAllowRulesFromVPCById_Call) Return(_a0 error) *CloudProvider_RemoveInboundAllowRulesFromVPCById_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CloudProvider_RemoveInboundAllowRulesFromVPCById_Call) RunAndReturn(run func(context.Context, string, string, string, []string, []string, string) error) *CloudProvider_RemoveInboundAllowRulesFromVPCById_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveClustersData provides a mock function with given fields: ctx
func (_m *CloudProvider) RetrieveClustersData(ctx context.Context) ([]cluster.DiscoveredCluster, error) {
	ret := _m.Called(ctx)

	var r0 []cluster.DiscoveredCluster
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]cluster.DiscoveredCluster, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []cluster.DiscoveredCluster); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cluster.DiscoveredCluster)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloudProvider_RetrieveClustersData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveClustersData'
type CloudProvider_RetrieveClustersData_Call struct {
	*mock.Call
}

// RetrieveClustersData is a helper method to define mock.On call
//   - ctx context.Context
func (_e *CloudProvider_Expecter) RetrieveClustersData(ctx interface{}) *CloudProvider_RetrieveClustersData_Call {
	return &CloudProvider_RetrieveClustersData_Call{Call: _e.mock.On("RetrieveClustersData", ctx)}
}

func (_c *CloudProvider_RetrieveClustersData_Call) Run(run func(ctx context.Context)) *CloudProvider_RetrieveClustersData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *CloudProvider_RetrieveClustersData_Call) Return(_a0 []cluster.DiscoveredCluster, _a1 error) *CloudProvider_RetrieveClustersData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CloudProvider_RetrieveClustersData_Call) RunAndReturn(run func(context.Context) ([]cluster.DiscoveredCluster, error)) *CloudProvider_RetrieveClustersData_Call {
	_c.Call.Return(run)
	return _c
}

// NewCloudProvider creates a new instance of CloudProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCloudProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *CloudProvider {
	mock := &CloudProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
