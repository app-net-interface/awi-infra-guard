// Code generated by mockery v2.32.0. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	infrapb "github.com/app-net-interface/awi-infra-guard/grpc/go/infrapb"

	mock "github.com/stretchr/testify/mock"
)

// AccessControlServiceClient is an autogenerated mock type for the AccessControlServiceClient type
type AccessControlServiceClient struct {
	mock.Mock
}

type AccessControlServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *AccessControlServiceClient) EXPECT() *AccessControlServiceClient_Expecter {
	return &AccessControlServiceClient_Expecter{mock: &_m.Mock}
}

// AddInboundAllowRuleByInstanceIPMatch provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) AddInboundAllowRuleByInstanceIPMatch(ctx context.Context, in *infrapb.AddInboundAllowRuleByInstanceIPMatchRequest, opts ...grpc.CallOption) (*infrapb.AddInboundAllowRuleByInstanceIPMatchResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.AddInboundAllowRuleByInstanceIPMatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleByInstanceIPMatchRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleByInstanceIPMatchResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleByInstanceIPMatchRequest, ...grpc.CallOption) *infrapb.AddInboundAllowRuleByInstanceIPMatchResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.AddInboundAllowRuleByInstanceIPMatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.AddInboundAllowRuleByInstanceIPMatchRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleByInstanceIPMatch'
type AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call struct {
	*mock.Call
}

// AddInboundAllowRuleByInstanceIPMatch is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.AddInboundAllowRuleByInstanceIPMatchRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) AddInboundAllowRuleByInstanceIPMatch(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call {
	return &AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call{Call: _e.mock.On("AddInboundAllowRuleByInstanceIPMatch",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call) Run(run func(ctx context.Context, in *infrapb.AddInboundAllowRuleByInstanceIPMatchRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.AddInboundAllowRuleByInstanceIPMatchRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call) Return(_a0 *infrapb.AddInboundAllowRuleByInstanceIPMatchResponse, _a1 error) *AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call) RunAndReturn(run func(context.Context, *infrapb.AddInboundAllowRuleByInstanceIPMatchRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleByInstanceIPMatchResponse, error)) *AccessControlServiceClient_AddInboundAllowRuleByInstanceIPMatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleByLabelsMatch provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) AddInboundAllowRuleByLabelsMatch(ctx context.Context, in *infrapb.AddInboundAllowRuleByLabelsMatchRequest, opts ...grpc.CallOption) (*infrapb.AddInboundAllowRuleByLabelsMatchResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.AddInboundAllowRuleByLabelsMatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleByLabelsMatchRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleByLabelsMatchResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleByLabelsMatchRequest, ...grpc.CallOption) *infrapb.AddInboundAllowRuleByLabelsMatchResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.AddInboundAllowRuleByLabelsMatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.AddInboundAllowRuleByLabelsMatchRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleByLabelsMatch'
type AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call struct {
	*mock.Call
}

// AddInboundAllowRuleByLabelsMatch is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.AddInboundAllowRuleByLabelsMatchRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) AddInboundAllowRuleByLabelsMatch(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call {
	return &AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call{Call: _e.mock.On("AddInboundAllowRuleByLabelsMatch",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call) Run(run func(ctx context.Context, in *infrapb.AddInboundAllowRuleByLabelsMatchRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.AddInboundAllowRuleByLabelsMatchRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call) Return(_a0 *infrapb.AddInboundAllowRuleByLabelsMatchResponse, _a1 error) *AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call) RunAndReturn(run func(context.Context, *infrapb.AddInboundAllowRuleByLabelsMatchRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleByLabelsMatchResponse, error)) *AccessControlServiceClient_AddInboundAllowRuleByLabelsMatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleBySubnetMatch provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) AddInboundAllowRuleBySubnetMatch(ctx context.Context, in *infrapb.AddInboundAllowRuleBySubnetMatchRequest, opts ...grpc.CallOption) (*infrapb.AddInboundAllowRuleBySubnetMatchResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.AddInboundAllowRuleBySubnetMatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleBySubnetMatchRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleBySubnetMatchResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleBySubnetMatchRequest, ...grpc.CallOption) *infrapb.AddInboundAllowRuleBySubnetMatchResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.AddInboundAllowRuleBySubnetMatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.AddInboundAllowRuleBySubnetMatchRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleBySubnetMatch'
type AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call struct {
	*mock.Call
}

// AddInboundAllowRuleBySubnetMatch is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.AddInboundAllowRuleBySubnetMatchRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) AddInboundAllowRuleBySubnetMatch(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call {
	return &AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call{Call: _e.mock.On("AddInboundAllowRuleBySubnetMatch",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call) Run(run func(ctx context.Context, in *infrapb.AddInboundAllowRuleBySubnetMatchRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.AddInboundAllowRuleBySubnetMatchRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call) Return(_a0 *infrapb.AddInboundAllowRuleBySubnetMatchResponse, _a1 error) *AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call) RunAndReturn(run func(context.Context, *infrapb.AddInboundAllowRuleBySubnetMatchRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleBySubnetMatchResponse, error)) *AccessControlServiceClient_AddInboundAllowRuleBySubnetMatch_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleForLoadBalancerByDNS provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) AddInboundAllowRuleForLoadBalancerByDNS(ctx context.Context, in *infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest, opts ...grpc.CallOption) (*infrapb.AddInboundAllowRuleForLoadBalancerByDNSResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.AddInboundAllowRuleForLoadBalancerByDNSResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleForLoadBalancerByDNSResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest, ...grpc.CallOption) *infrapb.AddInboundAllowRuleForLoadBalancerByDNSResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.AddInboundAllowRuleForLoadBalancerByDNSResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleForLoadBalancerByDNS'
type AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call struct {
	*mock.Call
}

// AddInboundAllowRuleForLoadBalancerByDNS is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) AddInboundAllowRuleForLoadBalancerByDNS(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	return &AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call{Call: _e.mock.On("AddInboundAllowRuleForLoadBalancerByDNS",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call) Run(run func(ctx context.Context, in *infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call) Return(_a0 *infrapb.AddInboundAllowRuleForLoadBalancerByDNSResponse, _a1 error) *AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call) RunAndReturn(run func(context.Context, *infrapb.AddInboundAllowRuleForLoadBalancerByDNSRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleForLoadBalancerByDNSResponse, error)) *AccessControlServiceClient_AddInboundAllowRuleForLoadBalancerByDNS_Call {
	_c.Call.Return(run)
	return _c
}

// AddInboundAllowRuleInVPC provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) AddInboundAllowRuleInVPC(ctx context.Context, in *infrapb.AddInboundAllowRuleInVPCRequest, opts ...grpc.CallOption) (*infrapb.AddInboundAllowRuleInVPCResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.AddInboundAllowRuleInVPCResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleInVPCRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleInVPCResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.AddInboundAllowRuleInVPCRequest, ...grpc.CallOption) *infrapb.AddInboundAllowRuleInVPCResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.AddInboundAllowRuleInVPCResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.AddInboundAllowRuleInVPCRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_AddInboundAllowRuleInVPC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInboundAllowRuleInVPC'
type AccessControlServiceClient_AddInboundAllowRuleInVPC_Call struct {
	*mock.Call
}

// AddInboundAllowRuleInVPC is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.AddInboundAllowRuleInVPCRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) AddInboundAllowRuleInVPC(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_AddInboundAllowRuleInVPC_Call {
	return &AccessControlServiceClient_AddInboundAllowRuleInVPC_Call{Call: _e.mock.On("AddInboundAllowRuleInVPC",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleInVPC_Call) Run(run func(ctx context.Context, in *infrapb.AddInboundAllowRuleInVPCRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_AddInboundAllowRuleInVPC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.AddInboundAllowRuleInVPCRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleInVPC_Call) Return(_a0 *infrapb.AddInboundAllowRuleInVPCResponse, _a1 error) *AccessControlServiceClient_AddInboundAllowRuleInVPC_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_AddInboundAllowRuleInVPC_Call) RunAndReturn(run func(context.Context, *infrapb.AddInboundAllowRuleInVPCRequest, ...grpc.CallOption) (*infrapb.AddInboundAllowRuleInVPCResponse, error)) *AccessControlServiceClient_AddInboundAllowRuleInVPC_Call {
	_c.Call.Return(run)
	return _c
}

// RefreshInboundAllowRule provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) RefreshInboundAllowRule(ctx context.Context, in *infrapb.RefreshInboundAllowRuleRequest, opts ...grpc.CallOption) (*infrapb.RefreshInboundAllowRuleResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.RefreshInboundAllowRuleResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RefreshInboundAllowRuleRequest, ...grpc.CallOption) (*infrapb.RefreshInboundAllowRuleResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RefreshInboundAllowRuleRequest, ...grpc.CallOption) *infrapb.RefreshInboundAllowRuleResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.RefreshInboundAllowRuleResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.RefreshInboundAllowRuleRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_RefreshInboundAllowRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefreshInboundAllowRule'
type AccessControlServiceClient_RefreshInboundAllowRule_Call struct {
	*mock.Call
}

// RefreshInboundAllowRule is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.RefreshInboundAllowRuleRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) RefreshInboundAllowRule(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_RefreshInboundAllowRule_Call {
	return &AccessControlServiceClient_RefreshInboundAllowRule_Call{Call: _e.mock.On("RefreshInboundAllowRule",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_RefreshInboundAllowRule_Call) Run(run func(ctx context.Context, in *infrapb.RefreshInboundAllowRuleRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_RefreshInboundAllowRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.RefreshInboundAllowRuleRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_RefreshInboundAllowRule_Call) Return(_a0 *infrapb.RefreshInboundAllowRuleResponse, _a1 error) *AccessControlServiceClient_RefreshInboundAllowRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_RefreshInboundAllowRule_Call) RunAndReturn(run func(context.Context, *infrapb.RefreshInboundAllowRuleRequest, ...grpc.CallOption) (*infrapb.RefreshInboundAllowRuleResponse, error)) *AccessControlServiceClient_RefreshInboundAllowRule_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveInboundAllowRuleFromVPCByName provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) RemoveInboundAllowRuleFromVPCByName(ctx context.Context, in *infrapb.RemoveInboundAllowRuleFromVPCByNameRequest, opts ...grpc.CallOption) (*infrapb.RemoveInboundAllowRuleFromVPCByNameResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.RemoveInboundAllowRuleFromVPCByNameResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RemoveInboundAllowRuleFromVPCByNameRequest, ...grpc.CallOption) (*infrapb.RemoveInboundAllowRuleFromVPCByNameResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RemoveInboundAllowRuleFromVPCByNameRequest, ...grpc.CallOption) *infrapb.RemoveInboundAllowRuleFromVPCByNameResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.RemoveInboundAllowRuleFromVPCByNameResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.RemoveInboundAllowRuleFromVPCByNameRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveInboundAllowRuleFromVPCByName'
type AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call struct {
	*mock.Call
}

// RemoveInboundAllowRuleFromVPCByName is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.RemoveInboundAllowRuleFromVPCByNameRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) RemoveInboundAllowRuleFromVPCByName(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call {
	return &AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call{Call: _e.mock.On("RemoveInboundAllowRuleFromVPCByName",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call) Run(run func(ctx context.Context, in *infrapb.RemoveInboundAllowRuleFromVPCByNameRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.RemoveInboundAllowRuleFromVPCByNameRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call) Return(_a0 *infrapb.RemoveInboundAllowRuleFromVPCByNameResponse, _a1 error) *AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call) RunAndReturn(run func(context.Context, *infrapb.RemoveInboundAllowRuleFromVPCByNameRequest, ...grpc.CallOption) (*infrapb.RemoveInboundAllowRuleFromVPCByNameResponse, error)) *AccessControlServiceClient_RemoveInboundAllowRuleFromVPCByName_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveInboundAllowRuleRulesByTags provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) RemoveInboundAllowRuleRulesByTags(ctx context.Context, in *infrapb.RemoveInboundAllowRuleRulesByTagsRequest, opts ...grpc.CallOption) (*infrapb.RemoveInboundAllowRuleRulesByTagsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.RemoveInboundAllowRuleRulesByTagsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RemoveInboundAllowRuleRulesByTagsRequest, ...grpc.CallOption) (*infrapb.RemoveInboundAllowRuleRulesByTagsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RemoveInboundAllowRuleRulesByTagsRequest, ...grpc.CallOption) *infrapb.RemoveInboundAllowRuleRulesByTagsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.RemoveInboundAllowRuleRulesByTagsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.RemoveInboundAllowRuleRulesByTagsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveInboundAllowRuleRulesByTags'
type AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call struct {
	*mock.Call
}

// RemoveInboundAllowRuleRulesByTags is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.RemoveInboundAllowRuleRulesByTagsRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) RemoveInboundAllowRuleRulesByTags(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call {
	return &AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call{Call: _e.mock.On("RemoveInboundAllowRuleRulesByTags",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call) Run(run func(ctx context.Context, in *infrapb.RemoveInboundAllowRuleRulesByTagsRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.RemoveInboundAllowRuleRulesByTagsRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call) Return(_a0 *infrapb.RemoveInboundAllowRuleRulesByTagsResponse, _a1 error) *AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call) RunAndReturn(run func(context.Context, *infrapb.RemoveInboundAllowRuleRulesByTagsRequest, ...grpc.CallOption) (*infrapb.RemoveInboundAllowRuleRulesByTagsResponse, error)) *AccessControlServiceClient_RemoveInboundAllowRuleRulesByTags_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveInboundAllowRulesFromVPCById provides a mock function with given fields: ctx, in, opts
func (_m *AccessControlServiceClient) RemoveInboundAllowRulesFromVPCById(ctx context.Context, in *infrapb.RemoveInboundAllowRulesFromVPCByIdRequest, opts ...grpc.CallOption) (*infrapb.RemoveInboundAllowRulesFromVPCByIdResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *infrapb.RemoveInboundAllowRulesFromVPCByIdResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RemoveInboundAllowRulesFromVPCByIdRequest, ...grpc.CallOption) (*infrapb.RemoveInboundAllowRulesFromVPCByIdResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *infrapb.RemoveInboundAllowRulesFromVPCByIdRequest, ...grpc.CallOption) *infrapb.RemoveInboundAllowRulesFromVPCByIdResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*infrapb.RemoveInboundAllowRulesFromVPCByIdResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *infrapb.RemoveInboundAllowRulesFromVPCByIdRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveInboundAllowRulesFromVPCById'
type AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call struct {
	*mock.Call
}

// RemoveInboundAllowRulesFromVPCById is a helper method to define mock.On call
//   - ctx context.Context
//   - in *infrapb.RemoveInboundAllowRulesFromVPCByIdRequest
//   - opts ...grpc.CallOption
func (_e *AccessControlServiceClient_Expecter) RemoveInboundAllowRulesFromVPCById(ctx interface{}, in interface{}, opts ...interface{}) *AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call {
	return &AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call{Call: _e.mock.On("RemoveInboundAllowRulesFromVPCById",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call) Run(run func(ctx context.Context, in *infrapb.RemoveInboundAllowRulesFromVPCByIdRequest, opts ...grpc.CallOption)) *AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*infrapb.RemoveInboundAllowRulesFromVPCByIdRequest), variadicArgs...)
	})
	return _c
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call) Return(_a0 *infrapb.RemoveInboundAllowRulesFromVPCByIdResponse, _a1 error) *AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call) RunAndReturn(run func(context.Context, *infrapb.RemoveInboundAllowRulesFromVPCByIdRequest, ...grpc.CallOption) (*infrapb.RemoveInboundAllowRulesFromVPCByIdResponse, error)) *AccessControlServiceClient_RemoveInboundAllowRulesFromVPCById_Call {
	_c.Call.Return(run)
	return _c
}

// NewAccessControlServiceClient creates a new instance of AccessControlServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAccessControlServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *AccessControlServiceClient {
	mock := &AccessControlServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
